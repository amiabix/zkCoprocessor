searchState.loadedDescShard("p3_field", 0, "A framework for finite fields.\nA generalization of <code>Field</code> which permits things like\nAn element of a finite field.\nA trait to constrain types that can be packed into a …\nSafety\nlike <code>Powers</code>, but packed into <code>PackedField</code> elements\nSafety\nAn iterator over the powers of a certain base element <code>b</code>: …\nA prime field of order less than <code>2^32</code>.\nA prime field of order less than <code>2^64</code>.\nThe number of factors of two in this field’s …\nA field which supplies information like the two-adicity of …\n<code>x += y * s</code>, where <code>s</code> is a scalar.\nSuppose this field extension is represented by the quotient\nReturn the representative of <code>value</code> that is less than …\nReturn the representative of <code>value</code> that is less than …\nBatch multiplicative inverses with Montgomery’s trick …\nExpand a product of binomials (x - roots[0])(x - roots[1]…\nComputes a coset of a multiplicative subgroup whose order …\nComputes a multiplicative subgroup whose order is known in …\nself / 2^exp\nself / 2^exp\nExponentiation by a <code>u64</code> power.\nExponentiation by a <code>u64</code> power.\nExponentiation by a <code>u64</code> power. This is similar to <code>exp_u64</code>, …\nExponentiation by a <code>u64</code> power. This is similar to <code>exp_u64</code>, …\nExtend a field <code>AF</code> element <code>x</code> to an array of length <code>D</code> by …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSimilar to <code>core:array::from_fn</code>, with the same caveats as …\nSuppose this field extension is represented by the quotient\nSimilar to <code>core:array::from_fn</code>.\nA generator of this field’s entire multiplicative group.\nComputes input/2. Should be overwritten by most field …\nComputes input/2. Should be overwritten by most field …\nGiven an element x from a 32 bit field F_P compute x/2.\nGiven an element x from a 64 bit field F_P compute x/2.\nTake interpret two vectors as chunks of <code>block_len</code> …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSuppose this field extension is represented by the quotient\nSuppose this field extension is represented by the quotient\nself * 2^exp\nself * 2^exp\nNaive polynomial multiplication.\nGiven a slice of SF elements, reduce them to a TF element …\nGiven an SF element, split it to a vector of TF elements …\nThe multiplicative inverse of this field element, if it …\nComputes <code>Z_{sH}(x)</code>, where <code>Z_{sH}</code> is the zerofier of the …\nReturns a generator of the multiplicative group of order …\nComputes <code>Z_H(x)</code>, where <code>Z_H</code> is the zerofier of a …\nBinomial extension field trait. A extension field with a …\nThe two-adicity of <code>p+1</code>, the order of the circle group.\nA field for which <code>p = 3 (mod 4)</code>. Equivalently, <code>-1</code> is not a …\nThe complex extension of this field has a binomial …\nOptional trait for implementing Two Adic Binomial …\nThe complex extension of this field has a two-adic …\nFrobeniusField automorphisms: x -&gt; x^n, where n is the …\nAlgorithm 11.3.4 in Handbook of Elliptic and Hyperelliptic …\nReturns the argument unchanged.\nConvert from <code>u64</code>. Undefined behavior if the input is …\nConvert from <code>usize</code>. Undefined behavior if the input is …\nCalls <code>U::from(self)</code>.\nRepeated Frobenius automorphisms: x -&gt; x^(n^count).")