searchState.loadedDescShard("sp1_lib", 0, "Syscalls for the SP1 zkVM.\nAn implementation of the types needed for <code>CurveArithmetic</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReads a buffer from the input stream.\nAllocates a buffer aligned to the given alignment.\nComputes a big integer operation with a modulus.\nExecutes a BLS12-381 curve addition on the given points.\nDecompresses a BLS12-381 point.\nExecutes a BLS12-381 curve doubling on the given point.\nExecutes a BLS12-381 Fp2 addition on the given inputs.\nExecutes a BLS12-381 Fp2 multiplication on the given …\nExecutes a BLS12-381 Fp2 subtraction on the given inputs.\nExecutes a BLS12-381 field addition on the given inputs.\nExecutes a BLS12-381 field multiplication on the given …\nExecutes a BLS12-381 field subtraction on the given inputs.\nExecutes a Bn254 curve addition on the given points.\nExecutes a Bn254 curve doubling on the given point.\nExecutes a BN254 Fp2 addition on the given inputs.\nExecutes a BN254 Fp2 multiplication on the given inputs.\nExecutes a BN254 Fp2 subtraction on the given inputs.\nExecutes a BN254 field addition on the given inputs.\nExecutes a BN254 field multiplication on the given inputs.\nExecutes a BN254 field subtraction on the given inputs.\nExecutes an Ed25519 curve addition on the given points.\nExecutes an Ed25519 curve decompression on the given point.\nEnters unconstrained mode.\nExits unconstrained mode.\nHalts the program with the given exit code.\nReturns the length of the next element in the hint stream.\nReads the next element in the hint stream into the given …\nExecutes the Keccak-256 permutation on the given state.\nReads the bytes from the given file descriptor into the …\nExecutes an Sepc256k1 curve addition on the given points.\nExecutes an Secp256k1 curve decompression on the given …\nExecutes an Secp256k1 curve doubling on the given point.\nExecutes an Secp256r1 curve addition on the given points.\nExecutes an Secp256r1 curve decompression on the given …\nExecutes an Secp256r1 curve doubling on the given point.\nExecutes the SHA-256 compress operation on the given word …\nExecutes the SHA-256 extend operation on the given word …\nExecutes a 256-bit by 2048-bit multiplication on the given …\nExecutes an uint256 multiplication on the given inputs.\nDefers the verification of a valid SP1 zkVM proof.\nWrites the bytes in the given buffer to the given file …\nExecutes a block of code unconstrained by the VM. This …\nA point on the BLS12-381 curve.\nThe number of limbs in [Bls12381AffinePoint].\nDecompresses a compressed public key using …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA point on the Bn254 curve.\nThe number of limbs in [Bn254AffinePoint].\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA <code>CurveArithmetic</code> extension for SP1 acceleration.\nAlias trait for the <code>SP1AffinePointTrait</code> with 32 byte field …\nThe <code>a</code> coefficient in the curve equation.\nThe <code>b</code> coefficient in the curve equation.\nAlias trait for the <code>ff::PrimeField</code> with 32 byte field …\nThe underlying <code>SP1AffinePointTrait</code> implementation.\nThe affine point type for SP1. Implementation of an affine …\nCreate an instance of self from a FieldBytes.\nEnsure the field element is normalized.\nThe projective point type for SP1. Implementation of the …\nConvert self to a FieldBytes.\nGet the x and y field elements of the point.\nReturns the argument unchanged.\nCreate an affine point from the given field elements, …\nGet the generator point.\nGet the identity point.\nCalls <code>U::from(self)</code>.\nCheck if the point is the identity point.\nEphemeral Diffie-Hellman Secret.\nShared secret value computed via ECDH key agreement.\nLow-level Elliptic Curve Diffie-Hellman (ECDH) function.\nCompute a Diffie-Hellman shared secret from an ephemeral …\nUse HKDF (HMAC-based Extract-and-Expand Key Derivation …\nReturns the argument unchanged.\nNOTE: this impl is intended to be used by curve …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the public key associated with this ephemeral secret.\nGenerate a cryptographically random <code>EphemeralSecret</code>.\nThis value contains the raw serialized x-coordinate of the …\nThe SP1 accelerated projective point.\nReturns the argument unchanged.\nThe inner affine point.\nCalls <code>U::from(self)</code>.\nCheck if the point is the identity point.\nConvert the projective point to an affine point.\nAn affine point on the Ed25519 curve.\nThe number of limbs in Ed25519AffinePoint.\nIn Edwards curves, doubling is the same as adding a point …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe file descriptor through which to access …\nThe file descriptor through which to access …\nThe file descriptor through which to access <code>hook_ecrecover</code>.\nThe file descriptor through which to access …\nThe file descriptor through which to access <code>hook_fp_inverse</code>…\nThe file descriptor through which to access <code>hook_fp_sqrt</code>.\nThe file descriptor for hints.\nThe file descriptor for public values.\nThe file descriptor through which to access …\nThe minimum file descriptor.\nCommit a serializable object to the public values stream.\nCommit bytes to the public values stream.\nHint a serializable object to the hint stream.\nHint bytes to the hint stream.\nRead a deserializable object from the input stream.\nRead a buffer from the input stream. The buffer is read …\nWrite the data <code>buf</code> to the file descriptor <code>fd</code>.\nThe number of limbs in Secp256k1Point.\nAn affine point on the Secp256k1 curve.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe number of limbs in Secp256r1Point.\nAn affine point on the Secp256k1 curve.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe generator.\nErrors that can occur during scalar multiplication of an …\nA trait for affine points on Weierstrass curves.\nA representation of a point on a Weierstrass curve.\nAdds the given <code>AffinePoint</code> to <code>self</code>.\nConverts a byte array in little endian to a slice of words.\nAdds the given <code>AffinePoint</code> to <code>self</code>. Can be optionally …\nDoubles <code>self</code>.\nCreates a new <code>AffinePoint</code> from the given x and y …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new <code>AffinePoint</code> from the given bytes in little …\nCreates a new <code>AffinePoint</code> that corresponds to the identity …\nThe infinity point representation of the Weierstrass …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if the point is the infinity point.\nReturns a mutable reference to the limbs. If the point is …\nReturns a reference to the limbs.\nMultiplies <code>self</code> by the given scalar.\nPerforms multi-scalar multiplication (MSM) on slices of …\nCreates a new <code>AffinePoint</code> from the given limbs.\nCreates a new <code>AffinePoint</code> from the given bytes in big …\nPerforms the complete addition of two <code>AffinePoint</code>’s on a …\nConverts a slice of words to a byte array in little endian.")