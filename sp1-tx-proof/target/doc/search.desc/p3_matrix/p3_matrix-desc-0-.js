searchState.loadedDescShard("p3_matrix", 0, "Matrix library.\nCompute Mᵀv, aka premultiply this matrix by the given …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWraps at the end.\nA matrix that is possibly bit-reversed, and can easily …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA dense matrix stored in row-major form.\nCreate a new dense matrix of the given dimensions, backed …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCompute <code>C = A * B</code>, where <code>A</code> in a CSR matrix and <code>B</code> is a …\nA RowIndexMap remaps row indices, and can change the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPermutations can optionally provide an optimized method to …\nA sparse matrix stored in the compressed sparse row format.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWe use this to wrap both the row iterator and the row …\nA combination of two matrices, stacked together vertically.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAssumes <code>i &lt; j</code>.")